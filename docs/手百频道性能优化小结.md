在进行双端开发的时候，跨端方案始终会被提起，常见的如React Native、Weex、Flutter都是大家的考量方案。而在百度内部，早在2017年React出现协议问题的时候，百度内部就考虑做一套自研方案，基于当时的React Native，我们将上层的React替换为[San]([https://github.com/baidu/san](https://github.com/baidu/san))，一套轻巧性能卓越的MVVM框架。而渲染层依然采用Yoga作为渲染引擎。在San之下，我们加了一层Fake Dom Api，它将San的层节点的Dom操作转为UIMessage，通知端上进行渲染。在内部，我们将Fake Dom Api这块简称为Html Native，简称HN。

在手百的频道列表页，大量的采用了这项技术。在这里，我们不再过多的介绍HN这些内容细节，而是着重介绍这篇文章的题目：手百频道白屏性能优化。文中存在一些可能大家并不熟悉的技术，但是思路如果觉得值得借鉴，我也会分享出来（有些是我做的有些是之前的同事做的哈）。

对于频道代码而言，它有三个大的生命周期，编译阶段、预加载阶段、运行阶段。本文也是按这三个阶段分别来说。

### 编译阶段
1. 预编译San组件
San不同与其他框架的点在于抽象节点[ANode]([https://github.com/baidu/san/blob/master/doc/anode.md](https://github.com/baidu/san/blob/master/doc/anode.md))，我们可以在编译时候将模板解析为ANode的JSON串，从而省去运行时编译耗时，当然缺点就是包体积会变大。不过经过验证对比，预编译产生的收益要大于包体积导致的影响。

2. CSS压缩与按平台编译
频道存在大量的卡片，每个类型卡片都是采用npm报的形式组织，在老版本中都是先将组件包进行编译后发布，这就导致在频道主库中只能全量引用编译后的包。更不幸的是，android和ios的less代码都被打包到了一个js文件（我们在less中支持了-android 和-ios前缀，以解决双端单独设置属性的需求）。之后我们引入lerna做包管理，而在主库，CSS实现按平台打包，同时使用css-loader的getLocalIdent，自定义一个极短uniq的className用于减小包大小。

### 预加载阶段
> 在手百运行启动后，就会使用 V8/JSC 加载JS Bundle，此时会进行JS的解析操作。

1. 加载CSS
HN运行时，需要计算Dom节点的样式，所以需要提前准备好各种选择器（类型选择器、类选择器、ID选择器）的计算属性，此时会在此处进行。

### 运行时阶段
运行时阶段也就是真正加载频道的时候，整体的优化思想就是复用、减少非首屏渲染外的额外操作。

1. 频道多页改单页
之前老版本为了更好的做数据隔离，所以运行时的window、document等对象都是单独一份，页面也是完全卸载替换的。而在新版本中，多个频道页面共享了更多的context资源，window、document等。

2. 非首屏渲染逻辑后移 | 删除
正如此标题说的，将一些非必要逻辑后移，比如打点后移，同时删除非必要的节点渲染（如闪屏Loading加载则使用端上方案）。

3. 请求NA化
与常见的调用端能力发请求有所区别，当时采用此方案是因为频道的主数据请求前，需要拼接参数，大概用到4-5个端能力，而端能力在前端Promise.all同时调用的时候，会偶发某个端能力耗时变多几百毫秒，所以也同样会影响后续的渲染。针对这个问题，这个网络请求，同端上写上模板语言，由端上帮我们做端能力的数据拼接，减少调用端能力失败率较高的问题。

4. 分屏渲染
当我们一次请求20条数据的时候，同时将20条数据全部渲染显然是会影响性能，。所以采用先渲染一屏幕（基于频道产品形态，一般是6条），然后再渲染剩余的频道。
